import os
import warnings
from collections import defaultdict
from functools import wraps

from libc.stdio cimport fputs, fputc
from libc.stdlib cimport malloc, free
from libc.string cimport strcpy

from .config import get_config, P_dpfile


cdef:
    int MAX_OPEN = 8
    str NAMESPACE = None
    str BASE_MCFUNC_PATH = None
    str LIBRARY_PATH = None
    str EXTRA_PATH = None


cdef class EnvCache(list):

    def __init__(self, int capacity = 12):
        if not (1 < capacity <= 128):
            raise ValueError(
                    "except the capacity ranging from 2 to 128, but get %d" % capacity
            )
        self._capacity = capacity
        super().__init__()
    
    cdef void _append(self, Context env):
        super().append(env)
        env.activate()
        cdef:
            int overflow = len(self) - self._capacity
            Context e
        if overflow > 0:
            for e in (<list>self)[:overflow]:
                e.deactivate()
    
    def append(self, Context env not None):
        self._append(env)
    
    cdef Context _pop(self):
        cdef:
            Context last = super().pop()
            Context next = (<list>self)[-1]
        last.deactivate()
        if self and not next.writable():
            next.activate(True)
        return last
    
    def pop(self):
        return self._pop()

    cdef void _clear(self):
        cdef Context e
        for e in (<list>self):
            e.deactivate()
        super().clear()
    
    def clear(self):
        self._clear()


cdef class EnvMethod:
    """
    Use the class as a decorator to
    announce a environment method.
    
    When called from the instance, the method works 
    as a normal method. And when it is called from the 
    class, the param 'self' will input <class>.current as 
    the instance.
    """

    def __init__(self, func: Callable):
        self.__func__ = func

    def __get__(self, instance, owner) -> Callable:
        if instance is None:
            instance = owner.top
            if not instance:
                raise McdpContextError("invalid current context")

        @wraps(self.__func__)
        def wrapper(*args, **kw):
            return self.__func__(instance, *args, **kw)

        return wrapper


cdef class EnvProperty(EnvMethod):

    def __get__(self, instance, owner) -> Any:
        return self.__func__(owner)
    

cdef EnvCache _envs = EnvCache(MAX_OPEN)


cdef class Context(McdpVar):
    """
    Core of bottom IO system.
    Each instance is a packing of the mcfunction file.
    
    """
    
    file_suffix = ".mcfunction"

    def __init__(
            self,
            str name not None,
            *,
            str root_path = None,
            hdls = None
    ):
        self.name = name
        self.stream = Stream(name + self.file_suffix, root=root_path or BASE_MCFUNC_PATH)
        if hdls is None:
            self.handlers = []
        elif callable(hdls):
            self.handlers = [hdls,]
        else:
            self.handlers = hdls
    
    cpdef void mkhead(self) except *:
        cdef:
            config = get_config()
            Version v = config.support_version
        self.comment(
            "Datapack %s generated by Mcdp." % config.name,
            "Supported Minecraft version: %s(%s)" % (v, get_version(v)),
        )
        self.newline()
    
    cpdef void write(self, str content) except *:
        self.stream.write(content)
    
    cpdef bint writable(self):
        return self.stream.writable()
    
    cpdef void activate(self, bint append = False) except *:
        if not append:
            self.stream.open("w")
            if get_config().pydp.add_comments:
                self.make_head()
        else:
            self.stream.open("a")
    
    cpdef void deactivate(self):
        self.stream.close()
    
    cdef void enter(self) except *:
        _envs._append(self)
    
    cdef void exit(self) except *:
        _envs._pop()
    
    def __enter__(self) -> Context:
        _envs._append(self)
        return self
    
    def __exit__(self, *args) -> None:
        if _envs._pop().name == "__init__":
            raise McdpContextError("Cannot leave the static stack '__init__'.")
    
    @EnvProperty
    def top(cls):
        if len(_envs) < 1:
            raise McdpContextError("Class 'Context' should be inited before used.")
        return _envs[-1]
    
    @EnvProperty
    def environments(cls):
        return _envs

    @EnvMethod
    def insert(self, *content: str) -> None:
        if not self.writable():
            raise McdpContextError("fail to insert command.")

        cdef:
            str command
            list l_cmd
            str c
            int counter = get_counter().commands
            
        for command in content:
            counter += 1

            if not command.endswith('\n'):
                command += '\n'
            
            if command.count('\n') > 1:
                l_cmd = command.split('\n')[:-1]
                for c in l_cmd:
                    for hdl in self.handlers:
                        c = hdl(c)
                    self.write(str(c) + '\n')
            else:
                for hdl in self.handlers:
                    command = hdl(command)
                self.write(str(command))

    @EnvMethod
    def comment(self, *content: str) -> None:
        if not self.writable():
            raise McdpContextError("fail to add comments.")
        cdef:
            list com = []
            str c
            list lc
        for c in content:
            if '\n' in c:
                lc = c.split('\n')
                com.extend(lc)
            else:
                com.append(c)

        self.write("# " + "\n# ".join(com) + '\n')
    
    @EnvMethod
    def newline(self, int line = 1) -> None:
        self.write('\n' * line)
    
    @EnvMethod
    def add_hdl(self, hdl) -> None:
        if not callable(hdl):
            raise McdpValueError("Command handler should be a callable object.")
        self.handlers.append(hdl)
    
    @EnvMethod
    def pop_hdl(self):
        return self.handlers.pop()

    def __repr__(self) -> str:
        return "<env %s in the context>" % self.name


cdef dict _tag_collections = {}


cdef class TagManager(McdpVar):
    __accessible__ = {"type": 3, "replace": 3, "@item": 3}

    collections = _tag_collections

    def __cinit__(
            self, 
            str type not None, 
            *, 
            str namespace = None, 
            bint replace = False
    ) -> None:
        if not type in ["blocks", "entity_types", "items", "fluids", "functions"]:
            raise McdpValueError("Invalid tag type '%s'" % type)
        self.type = type
        self.replace = replace
        if not namespace:
            namespace = get_namespace()
        self.root_path = namespace + "\\tags\\" + type
        self.cache = {}

        self.name = namespace + ":" + type
        self.collect()
    
    cpdef void add(self, str tag, str item, str namespace = None) except *:
        if not ":" in item:
            if not namespace:
                namespace = get_namespace()
            item = "%s:%s" % (namespace, item)

        cdef list litem = self[tag]
        if item in litem:
            warnings.warn("Try to add the tag '%s' twice." % tag)
        else:
            litem.append(item)

    def __getitem__(self, str key not None) -> List[str]:
        if not key in self.cache:
            self.cache[key] = []
        return self.cache[key]

    def __setitem__(self, str key not None, str item not None) -> None:
        self.add(key, item)

    cpdef dict get_tag_data(self, str tag, bint replace = False):
        if not tag in self.cache:
            raise McdpContextError("Cannot find tag '%s' in the cache." % tag)

        values = self.cache[tag]
        if not replace:
            replace = self.replace
        return {"replace": replace, "values": values}

    cpdef void apply_tag(self, str tag, bint replace = False) except *:
        if not tag in self.cache:
            raise McdpContextError("Tag '%s' did not defined." % tag)

        with Stream(tag + ".json", root=self.root_path) as stream:
            stream.dump(self.get_tag_data(tag, replace))

        del self.cache[tag]

    cpdef void apply(self):
        for tag in self.cache:
            self.apply_tag(tag)
    
    cdef void collect(self):
        _tag_collections[self.name] = self

    @classmethod
    def apply_all(cls):
        for i in _tag_collections.values():
            i.apply()
    
    def __dealloc__(self) -> None:
        if self.cache:
            self.apply()


cdef api void dp_insert(const char* cmd) except *:
    cdef:
        Context top = _envs[-1]
        tmp = cmd.decode()
    if not top.writable():
        raise McdpContextError("fail to insert command.")
    get_counter().commands += 1
    for hdl in top.handlers:
        tmp = hdl(tmp)
    top.stream.write(tmp)

cdef api void dp_comment(const char* cmt) except *:
    if not get_config().add_comments:
        return
    cdef Context top = _envs[-1]
    if not top.writable():
        raise McdpContextError("fail to add comments.")

    cdef:
        char buffer[129]
        int i = 2
    strcpy(buffer, "# ")
    while cmt[0]:
        if cmt[0] == ord('\n'):
            if i > 123:
                top.stream.fwrite(buffer)
                i = 0
            strcpy(buffer + i, "\n# ")
            i += 3
            cmt += 1
        else:
            if i > 126:
                top.stream.fwrite(buffer)
                i = 0
            buffer[i] = cmt[0]
            i += 1
            cmt += 1
    buffer[i] = ord('\n')
    buffer[i+1] = ord('\0')
    top.stream.fwrite(buffer)

cdef api void dp_commentline(const char* cmt, ...) except *:
    if not get_config().add_comments:
        return
    cdef Context top = _envs[-1]
    if not top.writable():
        raise McdpContextError("fail to add comments.")
    
    cdef va_list ap
    va_start(ap, cmt)
    fputs("# ", top.stream._file)
    try:
        top.stream.vformat(cmt, ap)
    finally:
        va_end(ap)
    fputc(ord("\n"), top.stream._file)

cdef api void dp_newline(int line) except *:
    if not get_config().add_comments:
        return
    cdef Context top = _envs[-1]
    if not top.writable():
        raise McdpContextError("fail to add comments.")

    cdef char* buffer = <char*>malloc((line + 1) * sizeof(char))
    if buffer == NULL:
        raise MemoryError
    cdef int i
    for i in range(line):
        buffer[i] = ord('\n')
    buffer[i] = 0
    top.stream.fwrite(buffer)
    free(buffer)

cdef api void dp_fastAddTag(const char* tag) except *:
    cdef Context ctx = _envs[-1]
    dp_addTag(tag.decode(), ctx.name, None)

cdef api void dp_addTag(str tag, str value, str m_name) except *:
    cdef:
        list nt
        str namespace
        TagManager m_tag
    if ':' in tag:
        nt = tag.split(':', 2)
        namespace = nt[0]
        tag = nt[1]
    else:
        namespace = get_namespace()
    if m_name is None:
        m_name = namespace + ":functions"
    m_tag = _tag_collections[m_name]
    m_tag.add(tag, value)

cdef api void dp_enter(str name, str root, list hdls) except *:
    cdef Context ctx = Context(name, root_path=root, hdls=hdls)
    _envs._append(ctx)
    
cdef api void dp_fastEnter(const char* name) except *:
    dp_enter(name.decode(), None, [])

cdef api void dp_exit() except *:
    _envs._pop()


def insert(*content: str) -> None:
    Context.insert(*content)

def comment(*content: str) -> None:
    if get_config().add_comments:
        Context.comment(*content)

def newline(line: int = 1) -> None:
    if get_config().add_comments:
        Context.newline(line)

def add_tag(
        str tag not None, 
        str value = None, 
        *, 
        str namespace = None, 
        str type = "functions"
) -> None:
    cdef:
        list nt
        TagManager m_tag
        Context c
    if ':' in tag:
        nt = tag.split(':', 2)
        namespace = nt[0]
        tag = nt[1]
    elif not namespace:
        namespace = get_namespace()

    if not value:
        if type == "functions":
            c = Context.top
            value = c.name
        else:
            raise McdpValueError("no value input.")
    m_tag = _tag_collections[f"{namespace}:{type}"]
    m_tag.add(tag, value)

cdef str get_namespace():
    return NAMESPACE

cdef inline str get_library_path():
    return LIBRARY_PATH

cdef inline str get_extra_path():
    return EXTRA_PATH

cdef inline void init_namespace(str nsp):
    global NAMESPACE, BASE_MCFUNC_PATH, LIBRARY_PATH, EXTRA_PATH
    NAMESPACE = nsp
    BASE_MCFUNC_PATH = nsp
    LIBRARY_PATH = nsp + "\\Library"
    EXTRA_PATH = nsp + "\\Extra"


cdef class McdpContextError(McdpError):

    def __init__(self, *arg: str) -> None:
        if _envs:
            self.context = _envs[-1]
        super(McdpError, self).__init__(*arg)